# =================================================================================
# =================================================================================
# Script:"data_analysis_of_spatial_patterns"
# Date: 2022-04-29
# Implemented by: Johannes Borgqvist
# Description:
# This script analyses the spatial patterns by reading in the concentration profile
# from the vtu-files generated by the FEM simulations. The main scripts here are
# numpy for handling arrays etc, meshio for reading the vtu file as well as
# extracting the data and lastly 
# =================================================================================
# =================================================================================
# Import Libraries
# =================================================================================
# =================================================================================
import meshio # To extract the important parts of the mesh
import numpy as np # Import numpy as well
import Schnakenberg_properties # Home made
from sklearn.cluster import DBSCAN # To calculate the number of poles in the concentration profile
from matplotlib import pyplot as plt # For plotting
# =================================================================================
# =================================================================================
# Functions
# =================================================================================
# =================================================================================
def plot_LaTeX_2D(t,y,file_str,plot_str,legend_str):
    # Open a file with the append option
    # so that we can write to the same
    # file multiple times
    f = open(file_str, "a")
    # Create a temporary string which
    # is the one that does the plotting.
    # Here we incorporate the input plot_str
    # which contains the color, and the markers
    # of the plot at hand
    if len(legend_str)==0:
        temp_str = "\\addplot[\nforget plot,\n" + plot_str+ "\n]\n"
    else:
        temp_str = "\\addplot[\n" + plot_str+ "\n]\n"
    # Add the coordinates
    temp_str += "coordinates {%\n"
    # Loop over the input files and add
    # them to the file
    for i in range(len(t)):
        temp_str += "(" + str(t[i]) + "," + str(y[i]) + ")\n"
    # The plotting is done, let's close the shop    
    temp_str += "};\n"
    # Add a legend if one is provided
    if len(legend_str) > 0:
        temp_str += "\\addlegendentry{" + legend_str + "}\n"
    # Finally, we write the huge string
    # we have created
    f.write("%s"%(temp_str))
    # Close the file
    f.close()
#----------------------------------------------------------------------------------
#----------------------------------------------------------------------------------
#----------------------------------------------------------------------------------
# Define the parameter pairs
#----------------------------------------------------------------------------------
#----------------------------------------------------------------------------------
#----------------------------------------------------------------------------------
# The parameters in the Schnakenberg model
a = 0.2
b = 1.0
# The wavenumber k^2
n = 2
k_squared = n*(n+1)
# Calculate the steady states and the critical parameters
u_0, v_0, d_c, gamma_c = Schnakenberg_properties.calculate_steady_states_and_critical_parameters_Schnakenberg(a,b,k_squared)
# Save the steady states in a list
steady_states = [u_0,v_0]
# Set the value of the relative diffusion
d = 18.0
# Set the value of the reaction strength to its critical value
gamma = gamma_c
# Define the number of holes
num_holes = 0
# Define the radius
radii_holes = []
# Define that we have the ICs around the steady states
ICs_around_steady_states = True
# Define the perturbation in the initial conditions
sigma = 1e-4
# Define the end time for the simulations
T = 50
# Let's start with the zeroth repitition
repitition_index = 0
#----------------------------------------------------------------------------------
#----------------------------------------------------------------------------------
#----------------------------------------------------------------------------------
# DEFINE THE FOLDERS WE LOOK THROUGH
#----------------------------------------------------------------------------------
#----------------------------------------------------------------------------------
#----------------------------------------------------------------------------------
folder_str = "../Output/"
a_str = "a_" + str(round(a,3)).replace(".","p") + "_"
b_str = "b_" + str(round(b,3)).replace(".","p") + "_"
d_str = "d_" + str(round(d,3)).replace(".","p") + "_"
gamma_str = "gamma_" + str(round(gamma,3)).replace(".","p") + "_"
sigma_str = "sigma_" + str(round(sigma,3)).replace(".","p") + "_"
T_str = "T_" + str(round(T,3)).replace(".","p") + "_"
if ICs_around_steady_states:
    IC_str = "ICs_around_steady_states/"
else:
    IC_str = "ICs_at_zero/"
# Let's start with the zeroth repitition
repitition_index = 0
# Define the meshes we want to loop over
hole_radius_array = np.arange(0,0.75,0.05)
# Define a parameter epsilon for the clustering
epsilon = 1
#----------------------------------------------------------------------------------
#----------------------------------------------------------------------------------
#----------------------------------------------------------------------------------
# Read the concentration profile and spatial coordinates
#----------------------------------------------------------------------------------
#----------------------------------------------------------------------------------
#----------------------------------------------------------------------------------
# Allocate memory for the three metric we will plot
rel_pol_area = []
num_poles_vec = []
max_conc = []
# Read ALL the data by looping over all hole radii
for hole_index in range(len(hole_radius_array)):
    if hole_index == 0:
        hole_str = "h_0_"
        radii_holes = []
    else:
        hole_str = "h_1_"
        radii_holes = [hole_radius_array[hole_index]]
    # Define an empty hole radius string    
    radius_str = ""
    # Loop over all raddi and read them one by one
    for radius in radii_holes:
        radius_str += "r_" + str(round(radius,3)).replace(".","p") + "_"
    # Gather all these substrings into one giant string where we will save the output files
    mesh_name = folder_str + hole_str + radius_str + a_str + b_str + d_str + gamma_str + sigma_str + T_str + IC_str + "iteration_" + str(repitition_index) + "/u000101"
    # Read the msh file
    conc_profile = meshio.read(mesh_name + ".vtu")
    # Extract the concentration profile
    u = np.asarray(list(conc_profile.point_data.values())[0])
    # Extract the spatial coordinates
    spatial_coordinates = conc_profile.points
    # Define a threshold concentration
    threshold_concentration = 0.8*max(u)
    # Save the spatial coordinates for which the concentration profile is above our threshold value
    pole_coordinates = np.asarray([spatial_coordinate for index,spatial_coordinate in enumerate(spatial_coordinates) if u[index]>=threshold_concentration])
    # CLUSTERING: conduct the density based scan using DBSCAN
    db = DBSCAN(eps=epsilon, min_samples=1).fit(pole_coordinates)
    cluster_labels = db.labels_
    # Get the number of poles
    num_poles = len(set(cluster_labels))
    relative_pole_area = 100*len(pole_coordinates)/len(u)
    # Append all values to our output vectors
    rel_pol_area.append(relative_pole_area)
    num_poles_vec.append(num_poles)
    max_conc.append(max(u))
#----------------------------------------------------------------------------------
#----------------------------------------------------------------------------------
#----------------------------------------------------------------------------------
# Plot our metrics as a function of the hole area
#----------------------------------------------------------------------------------
#----------------------------------------------------------------------------------
fig, axes = plt.subplots(1,3,figsize=(15,5))
plt.rc('axes', labelsize=25)    # fontsize of the x and y label
plt.rc('legend', fontsize=20)    # legend fontsize
plt.rc('xtick', labelsize=20)    # fontsize of the tick labels
plt.rc('ytick', labelsize=20)    # fontsize of the tick labels
# add a big axis, hide frame
fig.add_subplot(111, frameon=False)
# Subplot 1 of 3
axes[0].plot(hole_radius_array,np.asarray(rel_pol_area),'-',color=(115/256,115/256,115/256),label="Relative pole area in %")
axes[0].legend(loc='lower left')
# Subplot 2 of 3
axes[1].plot(hole_radius_array,np.asarray(num_poles_vec),'-',color=(77/256,0/256,75/256),label="Number of poles")
axes[1].legend(loc='lower left')
# Subplot 3 of 3
axes[2].plot(hole_radius_array,np.asarray(max_conc),'-',color=(129/256,15/256,124/256),label="Maximum concentration")
axes[2].legend(loc='lower left')
#hide tick and tick label of the big axis
plt.tick_params(labelcolor='none', which='both', top=False, bottom=False, left=False, right=False)
#plt.xlabel("Geodesic hole radius, $\\varepsilon$")
plt.xlabel("Cylindrical hole radius, $\\varepsilon$")
plt.ylabel("Metrics of pole formation")
# displaying the title
plt.title("Metrics of pole formation as functions of the hole radius $\\varepsilon$",fontsize=30, fontweight='bold')
plt.show()
plt.savefig("../Figures/patterns_are_preserved_growing_hole_radii.png")
#----------------------------------------------------------------------------------
#----------------------------------------------------------------------------------
# Save out plots as LaTeX plots as well
#----------------------------------------------------------------------------------
#----------------------------------------------------------------------------------
plot_LaTeX_2D(hole_radius_array,np.asarray(rel_pol_area),"../Figures/metrics_pole_formation_growing_radii/Input/relative_pole_area.tex","densely dashed, thin, color=eigen_2_0,line width=1pt,",[])
plot_LaTeX_2D(hole_radius_array,np.asarray(num_poles_vec),"../Figures/metrics_pole_formation_growing_radii/Input/num_poles.tex","densely dashed, thin, color=eigen_3_0,line width=1pt,",[])
plot_LaTeX_2D(hole_radius_array,np.asarray(max_conc),"../Figures/metrics_pole_formation_growing_radii/Input/max_conc.tex","densely dashed, thin, color=eigen_4_0,line width=1pt,",[])
